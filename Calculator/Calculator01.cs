namespace Calculator
{
    /* 과제. 작업 일정 계산기
       다음의 조건을 충족하는 작업 일정 계산기 프로그램을 구현하시오.

      1. 하루에 8시간씩 일하는 회사가 있으며, 남는 시간 없이 주어진 일을 계속한다.
      2. 각 작업이 몇시간이 걸리는 작업인지 포함하는 배열을 받을 때,
         각각의 작업이 끝나는 날짜를 '결과 배열' 로 출력하는 합수를 작성하자.

      예시 )

      입력 : [4, 4, 12, 10, 2, 10]
      출력 : [1, 1, 3, 4, 4, 6]

      ~ 해석 ~
      1일차 : 0번째 작업의 4/4 완료 + 1번쨰 작업의 4/4 완료.
      2일차 : 2번째 작업의 8/12 완료
      3일차 : 2번째 작업의 4/12 완료 + 3번째 작업의 4/10 완료
      4일차 : 3번째 작업의 6/10 완료 + 4번째 작업의 2/2 완료
      5일차 : 5번째 작업의 8/10 완료
      6일차 : 5번째 작업의 2/10 완료

    */

    /* 개인적인 풀이해석
     
            입력 : [4, 4, 12, 10, 2, 10]
            출력 : [1, 1, 3, 4, 4, 6] 
      입력값 : n시간
      출력값 : 입력값의 작업완료일차

      해석하자면
      입력 : [ 4시간, 4시간, 12시간, 10시간, 2시간, 10시간 ]
      출력 : [ 1일차완료, 1일차완료, 3일차완료, 4일차완료, 4일차완료, 6일차완료 ]

      1일차
      8시간 동안 작업을 시작
      0번째 작업 성공
      남은 4시간, 다음 배열에 사용
      1번째 작업 성공
      8시간 모두 사용. 다음날로 넘어감

      2일차
      8시간 동안 작업을 시작
      2번째 작업 미완 
      8시간 모두 사용. 다음날로 넘어감
      2번째 작업 성공까지 앞으로 4시간

      3일차
      8시간 동안 작업을 시작
      4시간을 들여 어제 완료하지 못한 2번째 작업 성공.
      남은 4시간, 다음 배열에 사용
      3번째 작업 미완
      8시간 모두 사용. 다음날로 넘어감
      3번째 작업 성공까지 앞으로 6시간

      4일차
      8시간 동안 작업을 시작
      6시간을 들여 어제 완료하지 못한 3번째 작업 성공.
      남은 2시간, 다음 배열에 사용
      4번째 작업 성공
      8시간 모두 사용. 다음날로 넘어감

      5일차
      8시간동안 작업을 시작
      5번째 작업 미완
      8시간 모두 사용. 다음날로 넘어감
      5번째 작업 성공까지 앞으로 2시간

      6일차
      8시간동안 작업을 시작
      2시간을 들여 어제 완료하지 못한 5번째 작업 성공.

    */

    // 1배열값이 0이 될 때 까지 8을 뺴는 함수 if? 반복문?
    // 8을 다 소비할 때 마다 Day+1
    // 
    /*
     int walk = 8;
      
       if (walk == 0)
    {
        Day ++
    }


    if (walk % 10 )
    {
        walk % 배열값 = int namuji;
        namuji = walk;
    }
     
    if (배열값 - walk =< 0)
    {
        배열에 Day 숫자를 넣음
        완료배열.AddLast(Day);
    }

     */


    public class Calculator01
    {

        public class TimeIn // 작업시간숫자 입력
        {
            int[] Inside = new int[10]; // 현재 배열 10개를 만듦. / 배열숫자 {'n'} = 'n'시간
            Queue<int> queue = new Queue<int>(); // 선입선출 - 후입후출 구조의 자료구조.


            public void InPut()
            {
                for (int i = 0; i < Inside.Length; i++) // i가 0일 때, InPut배열이 끝날 때 까지, i에 1을 더해준다.
                {
                    queue.Enqueue(Inside[i]); // Enqueue함수를 사용하여 배열값을 모두 queue에 선입선출로 넣어줌
                }
            }

            public void OutPut()
            {
                while (queue.Count > 0) ; // queue에 저장한 값을 모두 꺼낼 때 까지 반복한다.
                {
                    Console.WriteLine($"입력 : [{queue.Dequeue()}]");
                }

            }
        }

        public class TimeOut // n시간 배열에 따른 작업완료일차 출력 용도
        {
            int OneDayTime = 8; // 하루 8시간동안 일할 수 있음
            int Walk = 0; // 배열의 남은 업무량
            int[] Day = new int[10]; // 일차 표기를 위한 배열. 현재 10일차까지 존재.
            TimeIn timeIn;

            public void DayByDay()
            {
                for (int i = 1; timeIn[] != null; i++)
                {
                    if (OneDayTime == 0) // OneDayTime = 0 이 됐을 때, 다음날로 넘어간다.
                    {
                        Day[i]++;
                    }
                    else if (timeIn[i] == 0) // 배열값이 0이 됐을 때, 해당하는 Day를 출력값에 반환하고 다음 배열로 넘어간다.
                    {
                        timeIn.Next;
                    }
                    else // OneDayTime - 배열값을 계속 진행한다.
                    {
                        OneDayTime - timeIn[i] = Walk;
                        return Walk;
                    }
                }
            }
        }

        static void Main(string[] args)
        {

            // while (queue.Count > 0);
            //{
            //Console.WriteLine($"출력 : [{OutPut}]"); // 각 배열이 몇일차에 완료되었는지 출력
            //}
        }
    }
}
